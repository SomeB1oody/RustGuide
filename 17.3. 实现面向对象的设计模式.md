**喜欢的话别忘了点赞、收藏加关注哦（加关注即可阅读全文），对接下来的教程有兴趣的可以关注专栏。谢谢喵！(=^･ω･^=)**

# 17.3.1. 状态模式
*状态模式(state pattern)* 是一种面向对象设计模式，指的是一个值拥有的内部状态由数个*状态对象（state object）* 表达而成，而值的行为随着内部状态的改变而改变。

使用状态模式意味着：业务需求变化时，不需要修改持有状态的值的代码，或者是使用这个值的代码；只需要更新状态对象内部的代码，以改变其规则，或者是增加一些新的状态对象。

看个例子：

*博客文章一开始是一个空草稿。草稿完成后，要求对该帖子进行审查。当帖子获得批准后，就会发布。只有已发布的博客帖子才会返回要打印的内容，因此不会意外发布未经批准的帖子。*

`main.rs`:
```rust
use blog::Post;

fn main() {
    let mut post = Post::new();

    post.add_text("I ate a salad for lunch today");
    assert_eq!("", post.content());

    post.request_review();
    assert_eq!("", post.content());

    post.approve();
    assert_eq!("I ate a salad for lunch today", post.content());
}
```
- 使用`Post::new`创建新的博客文章草稿。首先创建一个`Post`类型的实例，命名为`post`。它是可变的，因为处于草稿状态的文章还可以修改
- 然后通过`Post`上的`add_text`方法增加了"I ate a salad for lunch today"这句话
- 接下来使用`request_review`方法请求审批
- 最后使用`approve`方法获得审批通过

*PS：添加的`assert_eq!`在代码中用于演示目的。单元测试可能包含断言草稿博客文章从`content`方法返回一个空字符串，但我们不打算为此示例编写测试。*

`lib.rs`:
```rust
pub struct Post {
    state: Option<Box<dyn State>>,
    content: String,
}

impl Post {
    pub fn new() -> Post {
        Post {
            state: Some(Box::new(Draft {})),
            content: String::new(),
        }
    }

	pub fn add_text(&mut self, text: &str) {
        self.content.push_str(text);
    }

	pub fn content(&self) -> &str {
        ""
    }

	pub fn request_review(&mut self) { 
		if let Some(s) = self.state.take() { 
			self.state = Some(s.request_review()) 
		} 
	}

	pub fn approve(&mut self) { 
		if let Some(s) = self.state.take() { 
			self.state = Some(s.approve()) 
		} 
	}
}

trait State {
    fn request_review(self: Box<Self>) -> Box<dyn State>;
    fn approve(self: Box<Self>) -> Box<dyn State>;
}

struct Draft {}

impl State for Draft {
    fn request_review(self: Box<Self>) -> Box<dyn State> {
        Box::new(PendingReview {})
    }
    
    fn approve(self: Box<Self>) -> Box<dyn State> { 
	    Box::new(Published {}) 
    }
}

struct PendingReview {}

impl State for PendingReview {
    fn request_review(self: Box<Self>) -> Box<dyn State> {
        self
    }
    
    fn approve(self: Box<Self>) -> Box<dyn State> { 
	    Box::new(Published {}) 
    }
}

struct Published {} 

impl State for Published { 
	fn request_review(self: Box<Self>) -> Box<dyn State> { 
		self 
	} 
	
	fn approve(self: Box<Self>) -> Box<dyn State> { 
	self 
	} 
}
```
- `Post`结构体有两个字段，一个字段是`state`，用于存储文章当下的状态，它一共有三种状态：草稿、等待审批和已发布。`Box<dyn State>`代表只要是实现了`State` trait的类型就可以存入
  通过这个字段，`Post`类型能在内部管理状态与状态之间的变化，这个状态的变化是通过用户调用`Post`上的方法实现的，而用户只能通过调用这些方法来改变值（因为`Post`下的字段未设为公开，所以用户没办法直接修改字段的值）。

- 下文通过`impl`块为`Post`实现了一些方法：
  - `new`函数用于创建一个`Post`类型的实例，其初始的`content`值是一个空的字符串；初始的`state`处于草稿状态，所以`state`存储的是`Draft`结构体（下文有讲）

  - `add_text`会往`content`字段使用`pusth_str`方法来添加内容

  - 即使我们调用了`add_text`并向帖子添加了一些内容，我们仍然希望`content`方法返回一个空字符串切片，因为帖子仍处于草稿状态。

  - `request_review`会提取出`state`字段下的状态，取出来之后，`State`就会暂时变为`None`，因为所有权被移动出来了。这个时候调用`state`上的`request_review`方法来请求审批。
  当`state`是`Draft`状态时，就会调用`Draft`结构体上的`request_review`方法（下文有讲），把`state`字段的值从`Draft`变为了`PendingReview`，把状态更新回`state`上。

- `approve`表示审批通过，其写法跟`request_review`差不多，把状态取出来，调用`self`上的`approve`方法来更新状态。

- `State` trait目前定义了两个方法，只有签名，没有具体实现：
  - `request_review`表示请求审批
  - `approve`表示审批通过
*PS：注意它的签名的参数是`Box<self>`，与`self`和`mut self`有区别，`Box<self>`意味着它只能被包裹着当前类型的`Box`实例，它会在调用过程中获取`Box(self)`的所有权，并使旧的实效，从而修改状态。*

- `Draft`用于表示草稿状态，不需要实际的内容，所以只要声明一个没有字段的结构体即可
- 通过`impl`块为`Draft`实现了`State` trait：
  - `request_review`表示请求审批，把值变为了`PendingReview`。
  - `approve`表示审批通过。由于`approve`在此时没用，只需要把本身传回去即可，所以返回值是`self`。

- `PendingReviewing`用于表示等待审批，不需要实际的内容，所以只要声明一个没有字段的结构体即可
- 通过`impl`块为`PendingReview`实现了`State` trait：
  - `request_review`表示请求审批，此时状态不会变，只需要把本身传回去即可，所以返回值是`self`。
  - `approve`表示审批通过，返回`Published`结构体。

- `Published`用于表示已发表，不需要实际的内容，所以只要声明一个没有字段的结构体即可
- 通过`impl`块为`Published`实现了`State` trait。但是它都处于已发布的状态了，所以`request_review`和`approve`都没啥用，直接返回本身`self`就行。

---

我们为什么不使用枚举类型的变体作为帖子状态？这当然是一个可能的解决方案，但它的其缺点之一是使用枚举是每个检查枚举值的地方都需要一个`match`表达式或类似的表达式来处理每个可能的变体。

---

这样写会存在很多重复的代码，有些代码根本没用；但是它的优点也很明显：无论状态值是什么`Post`上的`request_review`方法都不需要改变，每个状态都负责自己的运行规则。

这里还有`content`方法还需要修改，我们想要在发布状态下使它可见，而其他两种情况下看不到。一样可以使用面向对象的设计模式。以下是原来的代码：
```rust
pub fn content(&self) -> &str {
    ""
}
```

首先在`State` trait下定义`content`方法：
```rust
trait State {
    fn request_review(self: Box<Self>) -> Box<dyn State>;
    fn approve(self: Box<Self>) -> Box<dyn State>;
    fn content<'a>(&self, post: &'a Post) -> &'a str {
	    ""
    }
}
```
写了个默认实现，返回空字符串。注意这里要使用生命周期，因为接收的是`Post`的引用，然后返回的可能是`Post`中某一部分的引用，所以返回值的生命周期和`Post`参数的生命周期是相关联的。

对于`Draft`和`PendingReview`来说默认实现就可以满足需求了。只需要在`Published`中写一个方法覆盖默认实现：
```rust
impl State for Published { 
	fn request_review(self: Box<Self>) -> Box<dyn State> { 
		self 
	} 
	
	fn approve(self: Box<Self>) -> Box<dyn State> { 
	self 
	} 

	fn content<'a>(&self, post: &'a Post) -> &'a str {
		&post.content
	}
}
```

最后修改`Post`上的`content`方法：
```rust
impl Post {
    pub fn new() -> Post {
        Post {
            state: Some(Box::new(Draft {})),
            content: String::new(),
        }
    }

	pub fn add_text(&mut self, text: &str) {
        self.content.push_str(text);
    }

	pub fn content(&self) -> &str {
        self.state.as_ref().unwrap().content(&self)
    }

	pub fn request_review(&mut self) { 
		if let Some(s) = self.state.take() { 
			self.state = Some(s.request_review()) 
		} 
	}

	pub fn approve(&mut self) { 
		if let Some(s) = self.state.take() { 
			self.state = Some(s.approve()) 
		} 
	}
}
```
我们需要先看`Option`里面值的引用，所以说调用了`as_ref`方法得到`Option<&T>`，为了解包必须写一步错误处理，用`unwrap`即可。最后就调用`content`方法，根据所处的状态不同，`content`的具体实现也会有所不同。

# 17.3.2. 状态模式的取舍权衡
状态模式的优点如上所见：无论状态值是什么`Post`上的`request_review`方法都不需要改变，每个状态都负责自己的运行规则。

但它的缺点也比较明显：
- 需要重复实现一些逻辑代码
- 某些状态之间是相互耦合的，如果我们新增一个状态，这时候跟它相关联的代码就需要修改

# 17.3.3. 将状态和行为编码为类型
如果我们严格按照面向对象的模式写当然是可行的，但是发挥不出Rust的全部威力。

下面我们会结合Rust的特点来修改，具体来说就是把状态和行为改为具体的类型。Rust类型检查系统会通过编译时错误来阻止用户使用无效的状态。

修改后的代码如下：
`lib.rs`:
```rust
pub struct Post {
    content: String,
}

pub struct DraftPost {
    content: String,
}

impl Post {
    pub fn new() -> DraftPost {
        DraftPost {
            content: String::new(),
        }
    }

    pub fn content(&self) -> &str {
        &self.content
    }
}

impl DraftPost {
    pub fn add_text(&mut self, text: &str) {
        self.content.push_str(text);
    }

	pub fn request_review(self) -> PendingReviewPost {
        PendingReviewPost {
            content: self.content,
        }
    }
}

pub struct PendingReviewPost {
    content: String,
}

impl PendingReviewPost {
    pub fn approve(self) -> Post {
        Post {
            content: self.content,
        }
    }
}
```
- 声明了`Post`和`DraftPost`两个结构体，这两者都有一个存储`String`类型的`content`字段

- 通过`impl`块写了`Post`的`new`方法和`content`方法：
  - `new`方法会创建一个空的`DraftPost`结构体
  - `content`方法就会返回本身的`content`字段的值

- 通过`impl`块写了`DraftPost`的方法：
  - `add_text`方法用于给`DraftPost`的`content`添加文字
  - `request_review`方法用于请求审批，调用这个方法就会返回另一个状态`PendingReviewPost`,表示正在审批中。这个状态是在下文定义的

- 声明了`PendingReviewPost`结构体，有一个存储`String`类型的`content`字段。通过`impl`在它上面写了一个`approve`方法用于通过审批

这里的`Post`就指正式发布之后的`Post`，`DraftPost`就代表还处于草稿状态的文章，`PendingReviewPost`表示正在审批的文章。审批成功就会把`content`的值返回到`Post`的`content`字段里以供使用。

这样写不会出现意外的情况，因为只有通过审批正式发布的状态`Post`才有`content`方法来获取文章。

此时的`main.rs`写法也需要小改:
```rust
use blog::Post;

fn main() {
    let mut post = Post::new();

    post.add_text("I ate a salad for lunch today");

    let post = post.request_review();

    let post = post.approve();

    assert_eq!("I ate a salad for lunch today", post.content());
}
```

# 17.3.4. 总结
Rust不仅能够实现面向对象的设计模式，还可以支持更多的模式。例如将状态和行为编码为类型。

面对对象的经典模式并不总是Rust编程实践中的最佳选择，因为Rust具有其他面向对象语言所没有的所有权特性。


