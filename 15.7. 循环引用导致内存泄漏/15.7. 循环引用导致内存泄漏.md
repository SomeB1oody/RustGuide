*说句题外话，这篇文章真心很难，有看不懂可以在评论区问，我会尽快作答的。*

**喜欢的话别忘了点赞、收藏加关注哦（加关注即可阅读全文），对接下来的教程有兴趣的可以关注专栏。谢谢喵！(=^･ω･^=)**
# 15.7.1. 内存泄漏
Rust极高的安全性使得内存泄漏**很难出现**，但**并不是完全不可能**。

例如使用`Rc<T>`和`RefCell<T>`就可能创造出循环引用，造成内存泄漏：每个指针的引用计数都不会减少到0，值也不会被清理。

看个例子：
```rust
use crate::List::{Cons, Nil};
use std::cell::RefCell;
use std::rc::Rc;

#[derive(Debug)]
enum List {
    Cons(i32, RefCell<Rc<List>>),
    Nil,
}

impl List {
    fn tail(&self) -> Option<&RefCell<Rc<List>>> {
        match self {
            Cons(_, item) => Some(item),
            Nil => None,
        }
    }
}

fn main() {
    let a = Rc::new(Cons(5, RefCell::new(Rc::new(Nil))));

    println!("a initial rc count = {}", Rc::strong_count(&a));
    println!("a next item = {:?}", a.tail());

    let b = Rc::new(Cons(10, RefCell::new(Rc::clone(&a))));

    println!("a rc count after b creation = {}", Rc::strong_count(&a));
    println!("b initial rc count = {}", Rc::strong_count(&b));
    println!("b next item = {:?}", b.tail());

    if let Some(link) = a.tail() {
        *link.borrow_mut() = Rc::clone(&b);
    }

    println!("b rc count after changing a = {}", Rc::strong_count(&b));
    println!("a rc count after changing a = {}", Rc::strong_count(&a));
}
```
- 首先创建了一个链表`List`，使用`RefCell<T>`包裹`Rc<T>`使其内部值可被修改
- 通过`impl`块为`List`写了一个叫`tail`的方法，用于获取`List`下`Cons`变体附带的第二个元素，如果有就返回其值，用`Some`封装，是`Nil`就返回`None`。
- 然后在`main`函数创建了`a`、`b`两个`List`的实例，`b`内部共享了`a`的值。这种链表的代码看着就犯恶心，所以我把其结构图放在这里：
![[List.jpg]]
- `main`函数里还通过`Rc::strong_count`获取了`a`和`b`的强引用数量，使用自定义的`tail`方法获了`Cons`附带的第二个元素，用`println!`打印出来。
- 下面使用`if let`语句把`a`的`Cons`的第二个值绑在`link`上，通过`borrow_mut`方法获得其可变引用`&Cons`，使用解引用符号`*`把它转为`Cons`，最后把`b`的值通过`Rc::clone`共享赋给了`link`，也就改变了`a`内部的结构，变为了：
![[leak.png]]
*PS:我觉得自己画的太烂了，所以这里就换成Rust圣经的图片了*

输出:
```
a initial rc count = 1
a next item = Some(RefCell { value: Nil })
a rc count after b creation = 2
b initial rc count = 1
b next item = Some(RefCell { value: Cons(5, RefCell { value: Nil }) })
b rc count after changing a = 2
a rc count after changing a = 2
```
第1行到第5行：刚开始创建`a`时，引用数量就为1，当`b`被声明时，`a`被共享了，所以此时`a`的引用计数为2，`b`为1。

第六行到第7行：`if let`语句把`a`的内部结构改变了，使`a`的第二个元素指向`b`，`b`的引用数量加1变为2。此时`a`指向了`b`，`b`又指向了`a`，就会造成循环引用。

当`a`和`b`都走出了作用域，Rust删除了变量`b` ，这将`b`的引用计数从 2 减少到 1。此时`Rc<List>`在堆上的内存不会被删除，因为它的引用计数是1，而不是0。然后 Rust 删除`a` ，这会将`a`的`Rc<List>`实例的引用计数从 2 减少到 1，如图所示。这个实例的内存也不能被删除，因为另一个实例的内存 `Rc<List>`实例仍然引用它。分配给列表的内存将永远保持未回收状态。

接下来我们看看循环引用的内容是什么,使用这条代码：
```rust
println!("a next item = {:?}", a.tail());
```
Rust 将尝试打印此循环，其中`a`指向`b`指向`a`等等，直到溢出堆栈。最终的结果会是栈溢出错误。

# 15.7.2. 防止内存泄漏的方法
那有什么方法来防止内存泄漏吗？这只能依靠开发者，不能依靠Rust。

不然就只能重新组织数据结构，把引用拆分成持有和不持有所有权的两种情况，一些引用用来表达所有权，一些引用不表达所有权。循环引用的一部分具有所有权关系，另一部分不涉及所有权关系。这样写只有所有权的指向关系才会影响到值的清理。

# 15.7.3. 把`Rc<T>`换成`Weak<T>`以防止循环引用
我们知道`Rc::clone`会生成数据的强引用，使`Rc<T>`内部的引用计数加1，而`Rc<T>`只有在`strong_count`为0时才会被清理。

然而，`Rc<T>`实例通过调用`Rc::downgrade`方法创建值的弱引用(Weak Reference)。这个方法的返回类型是`weak<T>`（也是智能指针），每次调用`Rc::downgrade`会为`weak_count`加1而不是`strong_count`，所以弱引用并不影响`Rc<T>`的清理。

# 15.7.4. Strong vs. Weak
强引用(Strong Reference)是关于如何分析`Rc<T>`实例的所有权。弱引用(Weak Reference)并不表达上述意思，使用它不会创建循环引用：当强引用数量为0时，弱引用就会自动断开。

使用弱引用之前需要保证它指向的值仍然存在。在`Weak<T>`实例上调用`upgrade`方法，返回`Option<Rc<T>>`，通过`Option`枚举来完成值是否存在的验证。

看个例子：
```rust
use std::cell::RefCell;
use std::rc::Rc;

#[derive(Debug)]
struct Node {
    value: i32,
    children: RefCell<Vec<Rc<Node>>>,
}

fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        children: RefCell::new(vec![]),
    });

    let branch = Rc::new(Node {
        value: 5,
        children: RefCell::new(vec![Rc::clone(&leaf)]),
    });
}
```
`Node`结构体代表一个节点，有两个字段：
- `value`字段存储当前值，类型是`i32`。
- `children`字段存储子节点，类型是`RefCell<Vec<Rc<Node>>>`，这里使用`Rc<T>`是为了让所有子节点共享所有权。具体来说，我们希望一个`Node`拥有它的子节点，并且我们希望与储存这个节点的变量共享该所有权，以便我们可以直接访问树中的每个`Node` 。为此，我们将`Vec<T>`项定义为`Rc<Node>`类型的值。

这个例子的需求是每个节点都能指向自己的父节点和子节点。

再看一下`main`函数：
- 创建了`leaf`，是`Node`实例，`value`为3，`children`的值是被`RefCell`包裹的空`Vector`。
- 创建了`branch`，是`Node`实例，`value`为5，`children`的值指向了`leaf`。

这意味着`leaf`它里面的`Node`节点有两个所有者。目前可以通过`branch`的`children`字段访问`leaf`；而反过来如果想通过`leaf`来访问`branch`暂时还不行，所以这里还需要修改。

想要实现需求就得用双向引用，但是双向的引用会创建循环引用，所以这时候就得使用`Weak<T>`，避免产生循环：
```rust
struct Node {
    value: i32,
    parent: RefCell<Weak<Node>>,
    children: RefCell<Vec<Rc<Node>>>,
}
```
添加了`parent`字段表示父节点，使用弱引用`Weak<T>`。这里不用`Vec<>`是因为这是个树结构，父节点只可能有一个。

这么写得把`Weak<T>`引入作用域，还得重构下文，修改完后的整体代码如下：
```rust
use std::cell::RefCell;
use std::rc::{Rc, Weak};

#[derive(Debug)]
struct Node {
    value: i32,
    parent: RefCell<Weak<Node>>,
    children: RefCell<Vec<Rc<Node>>>,
}

fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![]),
    });

    println!("leaf parent = {:?}", leaf.parent.borrow().upgrade());

    let branch = Rc::new(Node {
        value: 5,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![Rc::clone(&leaf)]),
    });

    *leaf.parent.borrow_mut() = Rc::downgrade(&branch);

    println!("leaf parent = {:?}", leaf.parent.borrow().upgrade());
}
```
在`leaf`被创建后先打印了其`parent`字段的内容（这时`parent`字段还没有内容）；在`branch`被创建后打印了`leaf`的`parent`字段内容（这时其内容就是`branch`）。

`*leaf.parent.borrow_mut() = Rc::downgrade(&branch);`这句话把`branch`的内容从`Rc<Node>`变为`Weak<Node>`，指向了`leaf`的`parent`字段：
- `leaf.parent`是表示`leaf`父节点的字段，其类型是`RefCell<Weak<Node>>`，所以可以使用`borrow_mut`来获得其可变引用`&mut RefMut<Weak<Node>>`
- 使用解引用符号`*`把可变引用`&mut RefMut<Weak<Node>>`变为`RefMut<Weak<Node>>`
- 通过`downgrade`方法把`branch`的`Rc<Node>`变为`Weak<Node>`并赋给`parent`

输出：
```
leaf parent = None
leaf parent = Some(Node { value: 5, parent: RefCell { value: (Weak) },
children: RefCell { value: [Node { value: 3, parent: RefCell { value: (Weak) },
children: RefCell { value: [] } }] } })
```
- 第一次打印时其`parent`字段还没有被赋值，所以其值是`Option`下的`None`变体。
- 第二次打印时其父节点已被指定为`branch`，不是无限输出表明此代码没有创建循环引用。

最后我们通过修改`main`函数——添加打印语句和修改作用域来看看强引用和弱引用的数量：
```rust
fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![]),
    });

    println!(
        "leaf strong = {}, weak = {}",
        Rc::strong_count(&leaf),
        Rc::weak_count(&leaf),
    );

    {
        let branch = Rc::new(Node {
            value: 5,
            parent: RefCell::new(Weak::new()),
            children: RefCell::new(vec![Rc::clone(&leaf)]),
        });

        *leaf.parent.borrow_mut() = Rc::downgrade(&branch);

        println!(
            "branch strong = {}, weak = {}",
            Rc::strong_count(&branch),
            Rc::weak_count(&branch),
        );

        println!(
            "leaf strong = {}, weak = {}",
            Rc::strong_count(&leaf),
            Rc::weak_count(&leaf),
        );
    }

    println!("leaf parent = {:?}", leaf.parent.borrow().upgrade());
    println!(
        "leaf strong = {}, weak = {}",
        Rc::strong_count(&leaf),
        Rc::weak_count(&leaf),
    );
}
```
代码的逻辑是：
- 创建完`leaf`之后打印里面有多少强引用和弱引用

- 这部分完了之后加了`{}`，创建了新的作用域：
  - 把`branch`的声明和指定`leaf`父节点的操作放到里面
  - 打印`branch`和`leaf`在此时强引用、弱引用的数量

- 走出作用域后：
  - 打印`leaf`的`parent`
  - 打印`leaf`的强引用、弱引用

输出：
```
leaf strong = 1, weak = 0
branch strong = 1, weak = 1
leaf strong = 2, weak = 0
leaf parent = None
leaf strong = 1, weak = 0
```
- 第1行：创建了`leaf`，只有一个强引用
- 第2行：创建了`branch`，由于`branch`使用强引用对`leaf`进行了关联，其`parent`字段使用了`Weak::new()`创建，所以`branch`有1个强引用，一个弱引用
- 第3行：`branch`使用了`leaf`的强引用，其本身在声明时又是一个强引用，所以此时`leaf`就有两个强引用
- 第4行：由于`branch`已经走出其作用域，所以`leaf`的`parent`字段此时就为`None`
- 第5行：`branch`已经走出其作用域导致它对`leaf`的强引用失效，`leaf`的强引用减1变为1