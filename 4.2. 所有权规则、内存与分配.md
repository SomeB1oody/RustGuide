# 4.2.0 写在正文之前
在学习了Rust的通用编程概念后，就来到了整个Rust的重中之重——**所有权**，它跟其他语言都不太一样，很多初学者觉得学起来很难。这个章节就旨在让初学者能够完全掌握这个特性。

本章有三小节：
- 所有权：栈内存 vs. 堆内存
- **所有权规则、内存与分配（本文）**
- 所有权与函数

# 4.2.1. 所有权规则
所有权有三条规则：
- 每个值都有一个变量，这个变量是该值的所有者
- 每个值同时只能有一个所有者
- 当所有者超出作用域（scope）后，这个值将会被删除

# 4.2.2. 变量作用域
作用域（scope）就是程序中一个项目的有效范围
```rust
fn main(){
	//machine不可用
	let machine = 6657;//machine可用
	//可以对machine进行操作
}//machine的作用域到此结束，machine不再可用
```
在示例代码第三行声明了变量`machine`,而在第二行还没有声明变量所以在第二行它是不可用的。在第三行由于进行了声明所以它可用了。而在第四行就可以对`machine`进行相关操作了。在第五行`machine`的作用域就结束了，从第五行及以后，`machine`就不再可用了。

这个例子就涉及两个重点：
- `machine`在进入作用域后就变得有效了
- `machine`会保持自己的有效性直到离开作用域为止。
这两点和其他语言都类似，所以就不多说了。

# 4.2.3. String类型
为了演示所有权的一些相关规则，需要一个稍微复杂一点的数据类型，String类型就满足需求。

String类型比那些标量类型更复杂：之前的基础数据类型它们的数据都是存放在栈内存上的，它们在离开作用域时数据就会弹出栈；而**String类型是存储在堆内存上**的。

这章讲String类型主要是讲与所有权相关的部分，如果想要深入了解String类型本身就得等到后面了

字符串字面值（`&'static str`类型）是代码里手写的那些字符串值。但是它不能满足所有的需求，一是因为它们是**不可变**的；二是因为不是所有的字符串值都能在编写时确定（比如要获取输入）

对于这些情况，Rust提供了第二种字符串类型`String`。`String`类型能在堆上分配，它能够存储在编译时未知大小的文本。

# 4.2.4. 创建String类型的值
使用`from`函数从字符串字面值创建出`String`类型，例如：
```rust
let machine = String::from("6657");
```
- `::`表示`from`是`String`类型下的函数。可以理解为其他语言中的静态方法

这样声明的`String`类型就是可以修改的，例如：
```rust
fn main(){
	let mut machine = String::from("6657");
	machine.push_str(" up up!");
	println!("{}", machine);
}
```
- `let`后加上`mut`关键字代表这个变量`machine`是可以修改的
- `.push_str()`是这个变量上的一个方法，来向这个值的后边添加一个字符串字面值，示例中就是`" up up!"`

其输出效果为:
```
6657 up up!
```

为什么`String`类型是可以修改的，而`&'static str`(字符串字面值)不能：
- `String`是一个**堆分配**的可变字符串类型，可以动态增长或缩小其内容。
- 字符串字面值是`&'static str`类型，存储在程序的**静态内存**中（只读区域）。

# 4.2.5. 内存和分配
对于字符串字面值，因为它是写在源代码中的，所以在编译时就知道它的内容。其文本内容直接被硬编码到最终的可执行文件。它速度快、高效是得益于它的不可变性。

`String`类型为了支持可变形，需要在堆内存上分配内存老保存编译时未知的文本内容。这使得操作系统必须在运行时来请求内存（这步通过调用`String::from`来实现）。

当用完`String`之后，需要使用某种方式将内存返回给操作系统：
- 在有GC（垃圾回收器）的语言中，比如C#，GC会跟踪并清理不再使用的内存

- 在没有GC的语言中，比如C/C++，就需要程序员去识别内存何时不再使用，并调用代码将它返回。
  - 如果忘了，那就浪费内存
  - 如果提前做了，那变量就会变为非法
  - 如果做了两次，那就会出现非常严重的Bug——**二次释放(Double free)**，这可能导致某些正在使用的数据发生损坏，产生潜在的安全隐患。必须一次分配对应一次释放。

- Rust采用了不同的机制：对于某个值来说，当拥有它的变量走出作用范围时，Rust会调用一个特殊的函数——**drop函数**，内存会立即自动交还给操作系统，也就是内存会立即释放。

# 4.2.6. 变量与数据的交互方式
## 1.移动(Move)
多个变量可以与同一个数据使用一种独特的方式来交互。
```rust
let x = 5;
let y = x;
```
在这个例子中，5被绑定到`x`这个变量上边；在下一行相当于创建了`x`的副本，把`x`的副本绑定到`y`上。由于整数是已知且固定大小的简单的值，所以这两个5被压到了栈内存中。

但如果情况更加复杂，比如说是`String`类型时，情况又会有所不同。
```rust
let machine = String::from("Niko");
let wjq = machine;
```
在这个例子中，第一行通过`String`下的`from`函数从字符串字面值得到一个`String`类型的值叫`machine`。然后第二行把`machine`绑到`wjq`上。

虽然代码很相似，但***两者的运行方式是完全不一样的***。

首先我们得了解，一个`String`类型由三个部分组成（如下图所示）：
![[IMG_1218.jpeg]]

- 一个指向存放字符串内容的内存的指针（pointer）
- 一个长度
- 一个容量

这部分数据被压到了栈内存中，而存放字符串内容的部分在堆内存中，长度(len)就是存放字符串内容所需的字节数，容量(capacity)是指`String`从操作系统总共获得内存的总字节数。

当把`machine`的值赋给`wjq`时，是把栈内存上的数据复制给了`wjq`，而并没有复制指针所指向的堆内存上的数据。
![[IMG_1220.jpeg]]

当变量离开作用域时，Rust会自动调用`drop`函数，并将变量使用的堆内存释放，这是上文就说过的事，但当`machine`和`wjq`同时离开作用域时，它们都会尝试释放相同的内存，引发非常严重的bug，也就是**二次释放(Double free)**，其危害在上文就有解释，这里不做阐述。

为了保证内存安全，Rust会直接弃用第一个变量`machine`使其失效，把值移动到`wjq`上。当`machine`离开作用域时，Rust不需要释放任何有关变量`machine`的内存（当然`wjq`还是要释放的，因为它是有效的），因为`machine`已经失效。

如果在`machine`被弃用后还调用它就会报错（代码和运行效果如下）：
代码：
```rust
fn main(){
	let machine = String::from("Niko");
	let wjq = machine;
	println!("{}", machine);
}
```
运行效果：
```
error[E0382]: borrow of moved value: 'machine'
```

学习过其他语言的人可能接触过浅拷贝(shallow copy)和深拷贝(deep copy)。有些人会把这种复制指针、长度和容量视为浅拷贝，但由于Rust让`machine`失效了，所以这里使用新的术语:移动(Move)


这里隐藏了一个设计原则：**Rust不会自动创建数据的深拷贝**。也就是说，就运行时的性能而言，任何自动赋值的操作都是廉价的。

## 2. 克隆(Clone)
如果真想对堆内存上的`String`数据进行深度拷贝，而不仅仅是栈内存上的数据，那么可以使用`clone`方法。
```rust
let machine = String::from("Niko");
let wjq = machine.clone();
```
通过这种方法，无论是栈内存还是堆内存都被完整的复制了一份
![[IMG_1221.jpeg]]

但是克隆这种操作是比较消耗资源的,所以要谨慎使用。


## 3. Stack上的数据：复制
对于Stack上的数据，克隆是不需要的，复制就可以。
```rust
let x = 5;
let y = x;
println!("{},{}", x, y)
```
在这个例子中，`x`和`y`**都是有效的**，因为`x`是整数类型。整数类型是Rust中的基本类型（如`i32`、`u32`等），它们的大小在编译时就已经确定，并且它们的值完全存储在栈内存中。由于这些类型实现了**Copy trait**(可以把trait简单理解为接口)，赋值操作实际上是对值的直接拷贝，而不是对所有权的转移。

对于实现了Copy trait的类型，创建一个新的变量（如`y`）时会发生位拷贝操作，这种拷贝非常高效。同时，原变量（如`x`）仍然保持有效。因此，在这种情况下，调用`clone`方法与直接赋值没有任何区别，因为这两者的拷贝行为本质相同。

如果一个类型实现了Copy trait，那么旧的变量在赋值之后仍然可用。如果一个类型或者该类型的一部分实现了**Drop trait**，那么Rust就**不会允许它实现Copy trait**。

**一些拥有Copy trait的类型**：
- 任何简单的标量的组合类型都是可以实现Copy trait的
- 任何需要分配内存或某种资源的都不能实现Copy trait

对于元组（Tuple），如果其中所有的元素都是能实现Copy trait的，那么这个元组就可以的；如果其中但凡有一个不能实现Copy trait，那整个元组就不能。
- `(i32, u32)`可以实现Copy trait
- `(i32, String)`不能实现Copy trait，因为`String`不能实现Copy trait
 
