# 3.4.0. 写在正文之前
欢迎来到Rust自学的第三章，一共有6个小节，分别是:
- 变量与可变性
- 数据类型：标量类型
- 数据类型：复合类型
- **函数和注释（本文）**
- 控制流：`if else`
- 控制流：循环

通过第二章的小游戏(*没看的初学者强烈建议看一下*)，相信你已经学会了基本的Rust语法，而在第三章我们将更深一层，了解Rust中的通用的编程概念。

**喜欢的话记得点赞、收藏加关注哦，想要跟着学下去记得关注专栏哦**

# 3.4.1. 函数的基本认识
- 声明函数使用关键字`fn`
- 依照惯例，针对函数和变量名，使用蛇形命名规范：
  - 所有字母都是小写，单词之间使用下划线分开
  - 例子：`another_function`
- Rust语言不在乎自定义的函数写在被调用前还是被调用后，只要函数被声明了且能够被调用就可以，这比某些古老的语言要好得多（C/C++：有被冒犯到）。下面是一个例子，即使自定义函数写在在被声明后依然正常运行。
```rust
fn main(){
	println!("Hello World");
	another_function();
}

fn another_function(){
	println!("Another Function");
}
```

# 3.4.2. 函数的参数
函数的参数实际上有两个名词：parameter（形参）和argument（实参）
- **形参**指的是在定义函数或方法时声明的占位符，用来接收调用时传入的值。其作用是参数为函数提供一个通用的方式来处理外部数据，而不依赖具体的值。
- **实参**指的是传进这个函数的参数。其作用是为函数提供具体的值，供函数逻辑执行时使用。
```rust
fn main() {
    greet("Alice");
}

fn greet(name: &str) {
    println!("Hello, {}!", name);
}
```
在这个例子中:
- `main`函数中`greet`函数所填入的`"Alice"`就是**实参**,它是调用 greet 函数时传递给参数 name 的实际值。
- `greet`函数的`name`是一个**形参**，表示函数 greet 需要一个`&str`类型的值作为输入。

在函数签名里，**必须声明每个参数的类型**，因为这样做编译器就无需再对它进行推断了。在上个例子中，`name: &str`的`&str`就是name的类型。

函数可以有多个参数，每个参数都用逗号隔开。

# 3.4.3. 函数体中的语句和表达式
- 函数体由一系列语句组成，可选的由一个表达式结束
- Rust是一个**基于表达式**的语言，下面所讲的语法大部分都跟Scale很像，因为两者都是以**表达式为核心**的编程模型。
- 语句是执行一些动作的指令
- 表达式会计算产生一个值，**表达式本身就是一个值**
- 函数的定义也是语句
- 语句不返回值，所以不可以使用`let`把一个语句付给一个变量
```rust
fn main(){
	let x = (let y = 6);//Error: expected expression, found in statement(`let`)
}
```
在这个例子中，Rust编译器期待右边是一个表达式，但它发现了右边实际上是一个语句,所以就会报错。有些语言中可以实现类似的写法，但在Rust中不能。

```rust
fn main(){
	let y = {
		let x = 1;
		x + 3
	};
	println!("The value of y is:{}", y);
}
```
在这个例子中，`let y =`后面的大括号` {} `包含的代码块是一个表达式。这个代码块首先定义了一个变量 x 并赋值为 1，然后通过 x + 3 计算得出一个值。这里，`x + 3` 是一个表达式，而因为 `x + 3` 是代码块中最后一个表达式，所以它的值（1 + 3 的结果，4）就成为了整个代码块的返回值。最终，这个返回值被赋给变量 y。程序运行时会输出 The value of y is: 4。

如果在`x + 3`后加上分号 `;`，那么`x + 3`不再是一个表达式，而是一个语句。因为语句不会返回值，整个代码块的返回值就变成了`()`类型（即单元类型）。在 Rust 中,`()`是一个特殊的类型，它的唯一值是`()`本身。因此，如果在`x + 3`后加上分号，y 的类型就会是 `()`，这意味着 y 不再存储计算结果，而是存储了单元类型的值。需要注意的是，`()` 是一种有效的类型，但它不能通过 `println!` 直接打印。如果尝试打印 y，编译器会报错，提示无法格式化 `()` 类型的值。

# 3.4.4. 函数的返回值
- 在`->`符号后边声明函数返回值的类型，但是不可以为返回值命名。
- 在Rust里，返回值就是函数体里面最后一个表达式的值。
- 若想提前返回，需使用`return`关键字，并制定一个值。
```rust
fn machine() -> u32 {
	6657
}

fn main(){
	let wjq = machine();
	println!("The value of wjq is:{}", wjq);
}
```
在这个例子中，`machine`这个函数的返回值类型被声明为了`u32`,在这个函数的函数体中只有一个表达式，就是6657。它是表达式，所以后面没有分号。又因为它是这个函数的最后一个表达式（其实也就一个表达式），所以它就是这个函数的返回值。

# 3.4.5 注释
- 单行注释用`//`开头
- 多行注释用`/**/`结构
例子
```rust
fn machine() -> u32 {
	6657
}
/*let's go g2
let's go spirit
let's go navi
*/
fn main(){
	let wjq = machine();//6657 up up!
	println!("The value of wjq is:{}", wjq);
}
```

Rust还有一种很重要的文档注释，以后单独讲。
