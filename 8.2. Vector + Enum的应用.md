# 8.2.0. 本章内容
第八章主要讲的是Rust中常见的集合。Rust中提供了很多集合类型的数据结构，这些集合可以包含很多值。但是第八章所讲的集合与数组和元组有所不同。

第八章中的集合是存储在堆内存上而非栈内存上的，这也意味着这些集合的数据大小无需在编译时就确定，在运行时它们可以动态地变大或变小。

本章主要会讲三种集合：**Vector（本文）**、String和HashMap

**喜欢的话别忘了点赞、收藏加关注哦（加关注即可阅读全文），对接下来的教程有兴趣的可以关注专栏。谢谢喵！(=^･ω･^=)**
# 8.2.1. Vector和enum的互补
虽然`Vector`它可以动态地变大或变小，但是它里面元素的数据类型是必须一样的，但有的时候我们需要存储不同类型的数据在堆内存上，那这种情况怎么办呢？

还记得[6.1. 定义枚举](https://blog.csdn.net/weixin_71793197/article/details/144657604)中介绍的枚举类型吗，枚举的变体是**可以附加数据**的，而且这些附加的数据可以是不同类型。最主要的是，枚举类型的**变体都是定义在同一个枚举类型下的**，也就是说**所有的变体都是同一个类型**，就可以被存储到`Vector`中。

这样就可以通过枚举实现了在`Vector`里存储不同数据类型的数据的功能。

#  8.2.2. Vector + enum
来看一个实际使用`Vector`+枚举类型的例子：
```rust
enum SpreadSheetCell {  
    Int(i32),  
    Float(f64),  
    Text(String),  
}  
  
fn main() {  
    let row = vec![  
        SpreadSheetCell::Int(5567),  
        SpreadSheetCell::Text("up up".to_string()),  
        SpreadSheetCell::Float(114.514),  
    ];  
}
```
这个例子实现了模拟`Excel`单元格的功能，单元格内存储的只能是是整数、浮点数和字符串其中之一，所以声明了`SpreadSheetCell`这个枚举类型，拥有3个变体，分别用于存储整数（`Int`）、浮点数(`Float`)和字符串(`String`)。

在`main`函数中,声明了变量`row`用于存储一行的单元格，因为一行的单元格数量不确定，所以需要`Vector`来存储，在这里初始化时有三个单元格，第一个存储整数6657，第二个放了字符串"up up"，第三个放了浮点数114.514。

通过这个例子，我们可以看到通过使用可附加数据的枚举类型，就可以变相地在`Vector`里存放不同类型的数据。

那么Rust为什么在编译的时候就需要知道`Vector`里的元素的类型呢？因为这样Rust才能确定堆内存上到底需要多少内存来容纳这个`Vector`。除此之外，如果允许在`Vector`上存储不同类型的元素，那么在对`Vector`上的元素进行批量操作时，有些操作可能在某些类型上是合法的而在某些类型上不是，程序就会出错。而这种枚举类型配合`match`表达式的方式使得Rust能在编译时提前知晓所有的可能情况，在运行时就可以正确处理了。

在这个例子上`Vector`实现了存储不同的数据类型，但前提条件是我们必须知道到底有哪些数据类型（或者叫知道详尽的数据类型），否则的话，如果这个类型有无限种可能（或者叫不详尽），那么使用枚举也没有办法，连枚举都定义不出来。针对这种情况，Rust提供了trait，但这个得等到后面讲了。

